<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>영단어 문제지/답안지 PDF 생성기</title>

  <!-- SheetJS -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <!-- jsPDF -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <style>
    :root { --bd:#e5e7eb; --tx:#111827; --mut:#6b7280; --bg:#ffffff; }
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,"Apple SD Gothic Neo","Noto Sans KR",sans-serif; margin: 18px; color:var(--tx); background:var(--bg); }
    .card { max-width: 980px; margin: 0 auto; padding: 16px; border:1px solid var(--bd); border-radius: 12px; }
    h1 { font-size: 18px; margin: 0 0 10px; }
    .muted { color: var(--mut); font-size: 13px; line-height: 1.5; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin: 10px 0; }
    .row > * { flex: 0 0 auto; }
    label { font-size: 14px; }
    input[type="number"] { width: 110px; padding: 9px 10px; border: 1px solid #cfd4dc; border-radius: 10px; }
    input[type="file"] { padding: 8px; border: 1px dashed #cfd4dc; border-radius: 10px; }
    button { padding: 10px 12px; border-radius: 10px; border:1px solid #cfd4dc; background:#fff; cursor:pointer; }
    button.primary { background:#111827; color:#fff; border-color:#111827; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .pill { display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border:1px solid var(--bd); border-radius: 999px; font-size: 12px; color:var(--mut); }
    .ok { color:#065f46; }
    .warn { color:#92400e; }
    .err { color:#991b1b; }
    .hr { height:1px; background:var(--bd); margin: 14px 0; }
    .small { font-size: 12px; color:var(--mut); }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    @media (max-width:720px){ .grid2{ grid-template-columns: 1fr; } }
    .log { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
           font-size: 12px; background:#0b1020; color:#e5e7eb; padding:10px; border-radius:10px; white-space:pre-wrap; }
  </style>
</head>

<body>
  <div class="card">
    <h1>영단어 문제지/답안지 PDF 생성기</h1>
    <div class="muted">
      엑셀(<b>Sheet1</b>)을 읽어 Day 범위와 문항 수에 맞춰 <b>문제지 PDF</b>와 <b>답안지 PDF</b>를 각각 생성합니다.<br/>
      - 크롬(PC/안드로이드/맥)에서는 이전 파일 자동 불러오기를 지원합니다(권한 허용 시).<br/>
      - 사파리(iPhone 포함)는 보안 정책상 파일을 매번 선택해야 합니다.
    </div>

    <div class="hr"></div>

    <div class="grid2">
      <div>
        <div class="row">
          <button id="btnPick" class="primary">엑셀 선택(권장)</button>
          <span id="pillFs" class="pill">FS API: 확인중…</span>
        </div>
        <div class="row">
          <input id="fileInput" type="file" accept=".xlsx,.xls" />
          <span class="small">사파리/폴백용</span>
        </div>
        <div class="row">
          <button id="btnReopen">이전 파일 다시 열기</button>
          <span id="pillHandle" class="pill">이전 파일: 없음</span>
        </div>
      </div>

      <div>
        <div class="row">
          <label>Day 시작</label><input id="dayFrom" type="number" min="1" value="1" />
          <label>Day 끝</label><input id="dayTo" type="number" min="1" value="2" />
        </div>
        <div class="row">
          <label>Day당 문항 수</label><input id="perDay" type="number" min="1" value="30" />
          <span class="small">(예: Day마다 30개씩)</span>
        </div>
        <div class="row">
          <button id="btnGenerate" class="primary" disabled>PDF 생성</button>
          <span id="pillData" class="pill">데이터: 없음</span>
        </div>
      </div>
    </div>

    <div class="hr"></div>

    <div class="row">
      <span class="pill">폰트: <span id="pillFont">불러오는 중…</span></span>
      <span class="pill">시트: <span id="pillSheet">Sheet1</span></span>
    </div>

    <div id="log" class="log" style="margin-top:10px;">준비됨.</div>
  </div>

<script>
(() => {
  const { jsPDF } = window.jspdf;

  // ---------- DOM ----------
  const $ = (id) => document.getElementById(id);
  const logEl = $("log");
  const btnPick = $("btnPick");
  const btnReopen = $("btnReopen");
  const btnGenerate = $("btnGenerate");
  const fileInput = $("fileInput");

  const pillFs = $("pillFs");
  const pillHandle = $("pillHandle");
  const pillData = $("pillData");
  const pillFont = $("pillFont");
  const pillSheet = $("pillSheet");

  const dayFromEl = $("dayFrom");
  const dayToEl = $("dayTo");
  const perDayEl = $("perDay");

  function log(msg) {
    logEl.textContent = msg;
  }

  // ---------- Feature detect ----------
  const supportsFS = !!window.showOpenFilePicker && !!window.showSaveFilePicker;
  pillFs.textContent = "FS API: " + (supportsFS ? "지원됨(크롬/엣지)" : "미지원(사파리 등)");
  pillFs.classList.toggle("ok", supportsFS);
  pillFs.classList.toggle("warn", !supportsFS);

  // ---------- IndexedDB (store file handle) ----------
  const DB_NAME = "voca_pdf_db";
  const STORE = "handles";
  function openDB() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }
  async function idbSet(key, value) {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, "readwrite");
      tx.objectStore(STORE).put(value, key);
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  }
  async function idbGet(key) {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, "readonly");
      const req = tx.objectStore(STORE).get(key);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  // ---------- Font (NotoSansKR) ----------
  // NOTE: This fetches TTF and embeds into jsPDF at runtime.
  // If fetch fails (network/CORS), we fallback to built-in font (Korean may break).
  const FONT_NAME = "NotoSansKR";
  const FONT_STYLE = "normal";
  const FONT_URL = "https://cdn.jsdelivr.net/gh/googlefonts/noto-cjk@main/Sans/OTF/Korean/NotoSansKR-Regular.otf";

  let fontReady = false;

  async function fetchAsBase64(url) {
    const res = await fetch(url, { cache: "force-cache" });
    if (!res.ok) throw new Error("폰트 다운로드 실패: " + res.status);
    const buf = await res.arrayBuffer();
    // Convert ArrayBuffer -> base64
    let binary = "";
    const bytes = new Uint8Array(buf);
    const chunk = 0x8000;
    for (let i = 0; i < bytes.length; i += chunk) {
      binary += String.fromCharCode(...bytes.subarray(i, i + chunk));
    }
    return btoa(binary);
  }

  async function ensureFont(doc) {
    if (fontReady) return;
    try {
      pillFont.textContent = "다운로드 중…";
      const b64 = await fetchAsBase64(FONT_URL);
      doc.addFileToVFS("NotoSansKR-Regular.otf", b64);
      doc.addFont("NotoSansKR-Regular.otf", FONT_NAME, FONT_STYLE);
      fontReady = true;
      pillFont.textContent = "NotoSansKR 로드됨";
      pillFont.classList.remove("err");
      pillFont.classList.add("ok");
    } catch (e) {
      console.warn(e);
      pillFont.textContent = "폰트 로드 실패(기본폰트 사용)";
      pillFont.classList.remove("ok");
      pillFont.classList.add("err");
      fontReady = false;
    }
  }

  // ---------- Workbook state ----------
  let workbook = null;
  let parsedRows = []; // {day:number, word:string, meaning:string}
  let sourceName = "";

  function setDataPill(ok, text) {
    pillData.textContent = "데이터: " + text;
    pillData.classList.toggle("ok", ok);
    pillData.classList.toggle("warn", !ok);
  }

  function setHandlePill(ok, text) {
    pillHandle.textContent = "이전 파일: " + text;
    pillHandle.classList.toggle("ok", ok);
    pillHandle.classList.toggle("warn", !ok);
  }

  // ---------- Parsing helpers ----------
  function norm(v) { return String(v ?? "").replace(/\s+/g, " ").trim(); }
  function isIntStr(s) { return /^\d+$/.test(norm(s)); }
  function looksEnglish(s) { s = norm(s); return /[A-Za-z]/.test(s) && !/[가-힣]/.test(s); }
  function looksKorean(s) { s = norm(s); return /[가-힣]/.test(s); }

  // (A) No-header table like your screenshot:
  // col0: day number repeated, col1: word (english), col2: meaning (korean)
  function parseNoHeaderDayTable(ws) {
    const grid = XLSX.utils.sheet_to_json(ws, { header: 1, defval: "" })
      .map(row => row.map(v => norm(v)));

    const colCount = Math.max(0, ...grid.map(r => r.length));

    // find day column: highest int ratio
    const colScore = Array(colCount).fill(0);
    for (let c = 0; c < colCount; c++) {
      let ints = 0, nonEmpty = 0;
      for (let r = 0; r < grid.length; r++) {
        const v = grid[r][c] || "";
        if (!v) continue;
        nonEmpty++;
        if (isIntStr(v)) ints++;
      }
      colScore[c] = nonEmpty ? ints / nonEmpty : 0;
    }
    const dayCol = colScore.indexOf(Math.max(...colScore));
    if (dayCol < 0 || colScore[dayCol] < 0.6) return []; // not confident

    // find word/meaning columns to the right
    let wordCol = -1, meaningCol = -1;
    for (let c = 0; c < colCount; c++) {
      if (c === dayCol) continue;
      let eng=0, kor=0, nonEmpty=0;
      for (let r = 0; r < grid.length; r++) {
        const v = grid[r][c] || "";
        if (!v) continue;
        nonEmpty++;
        if (looksEnglish(v)) eng++;
        if (looksKorean(v)) kor++;
      }
      const engRatio = nonEmpty ? eng/nonEmpty : 0;
      const korRatio = nonEmpty ? kor/nonEmpty : 0;
      if (wordCol === -1 && engRatio > 0.5) wordCol = c;
      if (meaningCol === -1 && korRatio > 0.5) meaningCol = c;
    }
    if (wordCol === -1 || meaningCol === -1) return [];

    const out = [];
    for (const row of grid) {
      const day = row[dayCol] || "";
      const word = row[wordCol] || "";
      const meaning = row[meaningCol] || "";
      if (!isIntStr(day)) continue;
      if (!word || !meaning) continue;
      out.push({ day: Number(day), word, meaning });
    }
    return out;
  }

  // (B) If someday you also want to support "Day 1~2" style sheets, you can expand here.
  // For now we prioritize the "no-header day numeric column" format you described.
  function parseSheet1(ws) {
    const out = parseNoHeaderDayTable(ws);
    return out;
  }

  // ---------- Loading file ----------
  async function readFileToWorkbook(file) {
    const ab = await file.arrayBuffer();
    return XLSX.read(ab, { type: "array" });
  }

  async function loadWorkbook(wb, displayName) {
    workbook = wb;
    sourceName = displayName || "선택한 파일";
    const ws = wb.Sheets["Sheet1"];
    pillSheet.textContent = "Sheet1";
    if (!ws) {
      parsedRows = [];
      setDataPill(false, "Sheet1 없음");
      btnGenerate.disabled = true;
      log("에러: Sheet1 시트를 찾지 못했습니다.\n- 시트 이름을 Sheet1로 맞춰주세요.");
      return;
    }
    parsedRows = parseSheet1(ws);

    if (!parsedRows.length) {
      setDataPill(false, "파싱 실패");
      btnGenerate.disabled = true;
      log("파싱 실패: Sheet1에서 (Day 숫자 열 + 영단어 열 + 한글 뜻 열) 패턴을 찾지 못했습니다.\n- Day 숫자만 있는 열이 있고, 옆 열에 영단어/뜻이 들어있는지 확인해주세요.");
      return;
    }

    const days = [...new Set(parsedRows.map(r => r.day))].sort((a,b)=>a-b);
    setDataPill(true, `${sourceName} (${parsedRows.length}개, Day ${days[0]}~${days[days.length-1]})`);
    btnGenerate.disabled = false;
    log(`로드 완료: ${sourceName}\n- 총 ${parsedRows.length}개\n- Day 범위: ${days[0]} ~ ${days[days.length-1]}\n\n이제 Day 범위/문항 수를 입력하고 PDF 생성하면 됩니다.`);
  }

  // ---------- File picker (FS API) ----------
  async function pickWithFS() {
    if (!supportsFS) {
      log("이 브라우저는 파일 자동 재열기(FS API)를 지원하지 않습니다.\n오른쪽의 파일 선택(input)을 사용하세요.");
      return;
    }
    try {
      const [handle] = await window.showOpenFilePicker({
        types: [{ description: "Excel", accept: {
          "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": [".xlsx"],
          "application/vnd.ms-excel": [".xls"]
        }}]
      });
      if (!handle) return;
      const file = await handle.getFile();
      await idbSet("last_handle", handle);
      setHandlePill(true, file.name);
      const wb = await readFileToWorkbook(file);
      await loadWorkbook(wb, file.name);
    } catch (e) {
      log("파일 선택이 취소되었거나 오류가 발생했습니다.\n" + (e?.message || e));
    }
  }

  async function reopenLast() {
    if (!supportsFS) {
      log("이 브라우저는 이전 파일 자동 불러오기를 지원하지 않습니다(사파리 등).\n파일 선택(input)을 사용하세요.");
      return;
    }
    try {
      const handle = await idbGet("last_handle");
      if (!handle) {
        setHandlePill(false, "없음");
        log("저장된 이전 파일이 없습니다.\n먼저 '엑셀 선택(권장)'으로 파일을 한 번 선택해주세요.");
        return;
      }
      const perm = await handle.queryPermission({ mode: "read" });
      if (perm !== "granted") {
        const req = await handle.requestPermission({ mode: "read" });
        if (req !== "granted") {
          log("권한이 허용되지 않아 이전 파일을 다시 열 수 없습니다.\n다시 '엑셀 선택(권장)'으로 선택해주세요.");
          return;
        }
      }
      const file = await handle.getFile();
      setHandlePill(true, file.name);
      const wb = await readFileToWorkbook(file);
      await loadWorkbook(wb, file.name);
    } catch (e) {
      log("이전 파일을 여는 중 오류가 발생했습니다.\n" + (e?.message || e));
    }
  }

  // ---------- File input fallback ----------
  fileInput.addEventListener("change", async (ev) => {
    const file = ev.target.files?.[0];
    if (!file) return;
    setHandlePill(false, "폴백(input)");
    const wb = await readFileToWorkbook(file);
    await loadWorkbook(wb, file.name);
  });

  btnPick.addEventListener("click", pickWithFS);
  btnReopen.addEventListener("click", reopenLast);

  // try to show whether a handle exists
  (async () => {
    try {
      const handle = await idbGet("last_handle");
      if (handle) setHandlePill(true, "저장됨(재열기 가능)");
      else setHandlePill(false, "없음");
    } catch {
      setHandlePill(false, "사용 불가");
    }
  })();

  // ---------- PDF layout ----------
  // A4: 210x297mm. jsPDF default unit "mm" here.
  function drawHeader(doc, titleText) {
    doc.setFontSize(11);
    doc.text(titleText, 10, 10);

    // Name / Score boxes at top
    const y = 14;
    const boxH = 10;
    const leftW = 95;
    const rightW = 95;
    doc.rect(10, y, leftW, boxH);
    doc.rect(105, y, rightW, boxH);
    doc.setFontSize(10);
    doc.text("이름", 10 + leftW/2, y + 6, { align: "center" });
    doc.text("점수", 105 + rightW/2, y + 6, { align: "center" });
  }

  function drawTable(doc, x, y, w, rows, isAnswer) {
    // columns: 번호 / 단어 / 의미(또는 빈칸)
    const colNo = 12;
    const colWord = 38;
    const colMean = w - colNo - colWord;

    const rowH = 7;
    const headH = 7;

    // outer border + header row
    doc.setLineWidth(0.2);
    doc.rect(x, y, w, headH + rows.length * rowH);

    // vertical lines
    doc.line(x + colNo, y, x + colNo, y + headH + rows.length*rowH);
    doc.line(x + colNo + colWord, y, x + colNo + colWord, y + headH + rows.length*rowH);

    // header separator
    doc.line(x, y + headH, x + w, y + headH);

    doc.setFontSize(9);
    doc.text("번호", x + colNo/2, y + 4.8, { align: "center" });
    doc.text("단어", x + colNo + colWord/2, y + 4.8, { align: "center" });
    doc.text(isAnswer ? "의미" : "의미", x + colNo + colWord + colMean/2, y + 4.8, { align: "center" });

    // rows
    for (let i = 0; i < rows.length; i++) {
      const ry = y + headH + i * rowH;

      // horizontal line
      doc.line(x, ry + rowH, x + w, ry + rowH);

      const no = String(rows[i].no);
      const word = rows[i].word;
      const meaning = rows[i].meaning;

      doc.setFontSize(9);
      doc.text(no, x + colNo/2, ry + 4.9, { align: "center" });
      doc.text(word, x + colNo + 1.5, ry + 4.9);

      if (isAnswer) {
        doc.text(meaning, x + colNo + colWord + 1.5, ry + 4.9);
      } else {
        // problem sheet: leave blank (optionally draw light line)
        // doc.text("", ...)
      }
    }
  }

  function chunk(array, size) {
    const out = [];
    for (let i = 0; i < array.length; i += size) out.push(array.slice(i, i + size));
    return out;
  }

  function buildPagesForDayRange(data, dayFrom, dayTo, perDay) {
    // pick days, then take up to perDay each day, then concatenate in day order
    const days = [];
    for (let d = dayFrom; d <= dayTo; d++) days.push(d);

    const selected = [];
    for (const d of days) {
      const items = data.filter(r => r.day === d);
      selected.push(...items.slice(0, perDay));
    }

    // convert to numbered rows, then paginate 30 per page (15 left + 15 right)
    const numbered = selected.map((r, idx) => ({ no: idx + 1, word: r.word, meaning: r.meaning, day: r.day }));
    const pages = chunk(numbered, 30);
    return { pages, total: numbered.length };
  }

  // ---------- Saving ----------
  async function savePdf(doc, defaultName) {
    if (supportsFS) {
      try {
        const handle = await window.showSaveFilePicker({
          suggestedName: defaultName,
          types: [{ description: "PDF", accept: { "application/pdf": [".pdf"] } }]
        });
        const writable = await handle.createWritable();
        const blob = doc.output("blob");
        await writable.write(blob);
        await writable.close();
        return true;
      } catch (e) {
        // user canceled -> fallback download
      }
    }
    doc.save(defaultName);
    return true;
  }

  // ---------- Generate PDFs ----------
  btnGenerate.addEventListener("click", async () => {
    if (!parsedRows.length) return;

    const dayFrom = Number(dayFromEl.value || 1);
    const dayTo = Number(dayToEl.value || dayFrom);
    const perDay = Number(perDayEl.value || 30);

    if (!(dayFrom >= 1 && dayTo >= dayFrom)) {
      log("Day 범위를 확인해주세요. (시작 <= 끝)");
      return;
    }
    if (!(perDay >= 1)) {
      log("Day당 문항 수는 1 이상이어야 합니다.");
      return;
    }

    const { pages, total } = buildPagesForDayRange(parsedRows, dayFrom, dayTo, perDay);
    if (!total) {
      log(`선택한 Day 범위(Day ${dayFrom}~${dayTo})에 데이터가 없습니다.`);
      return;
    }

    // Problem PDF
    const prob = new jsPDF({ unit: "mm", format: "a4" });
    await ensureFont(prob);
    if (fontReady) prob.setFont(FONT_NAME, FONT_STYLE);

    // Answer PDF
    const ans = new jsPDF({ unit: "mm", format: "a4" });
    await ensureFont(ans);
    if (fontReady) ans.setFont(FONT_NAME, FONT_STYLE);

    const titleRange = `Day ${dayFrom}~${dayTo}`;
    const probName = `문제지_${titleRange}.pdf`;
    const ansName = `답안지_${titleRange}.pdf`;

    const pageDraw = (doc, pageRows, isAnswer, pageIndex) => {
      if (pageIndex > 0) doc.addPage();
      if (fontReady) doc.setFont(FONT_NAME, FONT_STYLE);

      drawHeader(doc, titleRange);

      // Two tables side by side
      const topY = 28;
      const tableW = 95;
      const leftX = 10;
      const rightX = 105;

      const leftRows = pageRows.slice(0, 15);
      const rightRows = pageRows.slice(15, 30);

      drawTable(doc, leftX, topY, tableW, leftRows, isAnswer);
      if (rightRows.length) drawTable(doc, rightX, topY, tableW, rightRows, isAnswer);
    };

    pages.forEach((pageRows, idx) => {
      pageDraw(prob, pageRows, false, idx);
      pageDraw(ans, pageRows, true, idx);
    });

    log(`PDF 생성 완료!\n- 선택 범위: ${titleRange}\n- 총 문항: ${total}\n- 페이지: ${pages.length}\n\n이제 저장을 진행합니다…`);

    await savePdf(prob, probName);
    await savePdf(ans, ansName);

    log(`완료!\n- ${probName}\n- ${ansName}\n\n팁: 크롬(PC/맥)에서는 '이전 파일 다시 열기'로 다음에도 빠르게 시작할 수 있어요.`);
  });

})();
</script>
</body>
</html>
