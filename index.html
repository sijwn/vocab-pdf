<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>영단어 문제지/답안지 PDF 생성기</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Apple SD Gothic Neo, "Noto Sans KR", sans-serif; margin: 18px; }
    .card { max-width: 860px; margin: 0 auto; padding: 16px; border: 1px solid #ddd; border-radius: 12px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin: 10px 0; }
    label { font-size: 14px; }
    input[type="number"] { width: 100px; padding: 8px; border: 1px solid #ccc; border-radius: 10px; }
    button { padding: 10px 14px; border: 0; border-radius: 10px; cursor: pointer; }
    button.primary { background: #111; color: #fff; }
    button.secondary { background: #eee; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .muted { color: #666; font-size: 13px; }
    .log { white-space: pre-wrap; background: #fafafa; border: 1px solid #eee; border-radius: 12px; padding: 12px; font-size: 13px; }
    .bad { color: #b00020; }
    .good { color: #0a7a3a; }
    .pill { display:inline-block; padding: 4px 10px; border: 1px solid #ddd; border-radius: 999px; font-size: 12px; color:#444; background:#fff; }
  </style>
</head>
<body>
  <div class="card">
    <h2 style="margin:0 0 8px;">영단어 문제지/답안지 PDF 생성기 (GitHub Pages)</h2>

    <div class="row" style="margin-top:14px;">
      <button class="secondary" id="pickBtn">엑셀 파일 불러오기</button>
      <button class="secondary" id="prevBtn" disabled>이전 파일 불러오기</button>
      <span class="pill" id="fileLabel">파일: (선택 안 됨)</span>
    </div>

    <!-- iOS/사파리 폴백 -->
    <input id="fileInput" type="file" accept=".xlsx,.xls" style="display:none" />

    <div class="row">
      <label>Day 범위:</label>
      <input id="dayStart" type="number" min="0" value="1" />
      <span>~</span>
      <input id="dayEnd" type="number" min="0" value="2" />
      <label style="margin-left:10px;">출제 개수:</label>
      <input id="count" type="number" min="1" value="30" />
    </div>

    <div class="row">
      <button class="primary" id="genBtn" disabled>PDF 생성</button>
      <button class="secondary" id="downloadQ" disabled>문제지.pdf 다운로드</button>
      <button class="secondary" id="downloadA" disabled>답안지.pdf 다운로드</button>
    </div>

    <div id="status" class="log" style="margin-top:12px;">대기 중…</div>

    <div class="muted" style="margin-top:10px;">
      시트 이름은 <b>Sheet1</b>을 우선 사용하고, 없으면 첫 번째 시트를 사용합니다. (A=day, B=단어, C=뜻)
    </div>
  </div>

  <script src="./xlsx.full.min.js"></script>
  <script src="./jspdf.umd.min.js"></script>

  <script>
    const $ = (id) => document.getElementById(id);
    const statusEl = $("status");

    // ===== 한글 폰트 (doc마다 등록해야 함!) =====
    const KOREAN_FONT_FILE = "./NotoSansKR-VariableFont_wght.ttf";
    const KOREAN_FONT_VFS_NAME = "NotoSansKR.ttf";
    const KOREAN_FONT_FAMILY = "NotoSansKR";

    let KOREAN_FONT_B64 = null; // base64는 캐싱
    async function fetchFontB64Once() {
      if (KOREAN_FONT_B64) return KOREAN_FONT_B64;

      const res = await fetch(KOREAN_FONT_FILE);
      if (!res.ok) throw new Error("한글 폰트 파일을 불러오지 못했습니다: " + KOREAN_FONT_FILE);

      const buf = await res.arrayBuffer();

      // 안전한 base64 변환(큰 파일 대응)
      const bytes = new Uint8Array(buf);
      let binary = "";
      const chunkSize = 0x8000;
      for (let i = 0; i < bytes.length; i += chunkSize) {
        binary += String.fromCharCode(...bytes.subarray(i, i + chunkSize));
      }
      KOREAN_FONT_B64 = btoa(binary);
      return KOREAN_FONT_B64;
    }

    async function ensureKoreanFont(doc) {
      const b64 = await fetchFontB64Once();

      // 중요: doc마다 폰트 등록(답안지 깨짐 방지)
      try {
        doc.addFileToVFS(KOREAN_FONT_VFS_NAME, b64);
      } catch (_) {}
      try {
        doc.addFont(KOREAN_FONT_VFS_NAME, KOREAN_FONT_FAMILY, "normal");
      } catch (_) {}

      doc.setFont(KOREAN_FONT_FAMILY, "normal");
    }

    // ===== 상태/유틸 =====
    let pdfBlobQ = null;
    let pdfBlobA = null;

    // FS Access 지원 브라우저용
    let currentHandle = null;
    // iOS/사파리용
    let currentFile = null;

    function log(msg, cls="") {
      statusEl.textContent = msg;
      statusEl.className = "log " + cls;
    }
    function assert(cond, msg) { if (!cond) throw new Error(msg); }
    function toInt(x) {
      const n = Number(x);
      if (!Number.isFinite(n)) return null;
      return Math.trunc(n);
    }
    function supportsFSAccess() {
      return !!window.showOpenFilePicker;
    }

    function parseFlexibleDayWordMean(data2d) {
      const norm = (v) => (v ?? "").toString().trim();
      const isInt = (v) => /^\d+$/.test(norm(v));
      const looksEnglish = (v) => /[A-Za-z]/.test(norm(v)) && !/[가-힣]/.test(norm(v));
      const looksKorean  = (v) => /[가-힣]/.test(norm(v));
    
      const rowCount = data2d.length;
      const colCount = Math.max(0, ...data2d.map(r => (r ? r.length : 0)));
    
      // 열별 점수: day(정수비율), eng(영어비율), kor(한글비율)
      const scores = Array.from({ length: colCount }, () => ({ nonEmpty:0, day:0, eng:0, kor:0 }));
    
      for (let r = 0; r < rowCount; r++) {
        const row = data2d[r] || [];
        for (let c = 0; c < colCount; c++) {
          const v = row[c];
          const s = norm(v);
          if (!s) continue;
          scores[c].nonEmpty++;
          if (isInt(s)) scores[c].day++;
          if (looksEnglish(s)) scores[c].eng++;
          if (looksKorean(s)) scores[c].kor++;
        }
      }
    
      const ratio = (num, den) => den ? num / den : 0;
    
      // Day 열: 정수 비율이 가장 높은 열 (단, 비어있지 않은 값이 어느 정도 있어야 함)
      let dayCol = -1, bestDay = 0;
      for (let c = 0; c < colCount; c++) {
        const nonEmpty = scores[c].nonEmpty;
        if (nonEmpty < 5) continue;
        const dayR = ratio(scores[c].day, nonEmpty);
        if (dayR > bestDay) { bestDay = dayR; dayCol = c; }
      }
      if (dayCol === -1 || bestDay < 0.7) return { rows: [], dayCol:-1, wordCol:-1, meanCol:-1 };
    
      // 단어/뜻 열: dayCol 제외하고 영어비율/한글비율이 높은 열
      let wordCol = -1, bestEng = 0;
      let meanCol = -1, bestKor = 0;
      for (let c = 0; c < colCount; c++) {
        if (c === dayCol) continue;
        const nonEmpty = scores[c].nonEmpty;
        if (nonEmpty < 5) continue;
    
        const engR = ratio(scores[c].eng, nonEmpty);
        const korR = ratio(scores[c].kor, nonEmpty);
    
        if (engR > bestEng) { bestEng = engR; wordCol = c; }
        if (korR > bestKor) { bestKor = korR; meanCol = c; }
      }
      if (wordCol === -1 || meanCol === -1) return { rows: [], dayCol, wordCol, meanCol };
    
      // 실제 rows 생성
      const rows = [];
      for (let r = 0; r < rowCount; r++) {
        const row = data2d[r] || [];
        const day = row[dayCol];
        if (!isInt(day)) continue;
        const d = Number(norm(day));
        const w = norm(row[wordCol]);
        const m = norm(row[meanCol]);
        if (!w) continue;
        rows.push({ day: d, word: w, mean: m });
      }
    
      return { rows, dayCol, wordCol, meanCol };
    }


    // ===== IndexedDB (FS Access용 “이전 파일”) =====
    const IDB_DB = "voca_pdf_app";
    const IDB_STORE = "kv";
    const KEY_HANDLE = "last_excel_handle";
    const KEY_LAST_NAME = "last_excel_name";

    function idbOpen() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(IDB_DB, 1);
        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains(IDB_STORE)) db.createObjectStore(IDB_STORE);
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }
    async function idbSet(key, value) {
      const db = await idbOpen();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(IDB_STORE, "readwrite");
        tx.objectStore(IDB_STORE).put(value, key);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }
    async function idbGet(key) {
      const db = await idbOpen();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(IDB_STORE, "readonly");
        const req = tx.objectStore(IDB_STORE).get(key);
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }
    async function saveLastHandle(handle) {
      await idbSet(KEY_HANDLE, handle);
      await idbSet(KEY_LAST_NAME, handle?.name || "");
    }
    async function loadLastHandle() { return await idbGet(KEY_HANDLE); }
    async function loadLastName() { return (await idbGet(KEY_LAST_NAME)) || ""; }

    // ===== 파일 선택(자동 폴백) =====
    async function pickExcelAuto() {
      pdfBlobQ = pdfBlobA = null;
      $("downloadQ").disabled = true;
      $("downloadA").disabled = true;

      if (supportsFSAccess()) {
        const [handle] = await window.showOpenFilePicker({
          multiple: false,
          types: [{
            description: "Excel 파일",
            accept: {
              "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": [".xlsx"],
              "application/vnd.ms-excel": [".xls"],
            }
          }],
        });
        assert(handle, "파일을 선택하지 않았습니다.");
        currentHandle = handle;
        currentFile = null;
        await saveLastHandle(handle);

        $("prevBtn").disabled = false;
        $("genBtn").disabled = false;
        $("fileLabel").textContent = `파일: ${handle.name}`;
        log("파일 선택 완료. ‘PDF 생성’을 눌러주세요.", "good");
      } else {
        $("fileInput").value = "";
        $("fileInput").click();
      }
    }

    async function usePreviousFile() {
      assert(supportsFSAccess(), "이 브라우저는 ‘이전 파일 불러오기’를 지원하지 않습니다. (iPhone/iPad는 파일을 다시 선택해야 할 수 있어요)");
      const handle = await loadLastHandle();
      assert(handle, "저장된 이전 파일이 없습니다. 먼저 ‘엑셀 파일 불러오기’로 파일을 선택해 주세요.");

      let perm = await handle.queryPermission({ mode: "read" });
      if (perm !== "granted") perm = await handle.requestPermission({ mode: "read" });
      assert(perm === "granted", "파일 접근 권한이 필요합니다. 권한을 허용해 주세요.");

      currentHandle = handle;
      currentFile = null;

      $("genBtn").disabled = false;
      $("fileLabel").textContent = `파일: ${handle.name}`;
      log("이전 파일 불러오기 완료. ‘PDF 생성’을 눌러주세요.", "good");
    }

    $("fileInput").addEventListener("change", () => {
      const f = $("fileInput").files?.[0];
      if (!f) return;
      currentFile = f;
      currentHandle = null;

      $("prevBtn").disabled = true;
      $("genBtn").disabled = false;
      $("fileLabel").textContent = `파일: ${f.name}`;
      log("파일 선택 완료. ‘PDF 생성’을 눌러주세요.", "good");
    });

    // ===== 엑셀 읽기 =====
    async function readExcelFromSource() {
      let buf;
      let shownName = "";
      if (currentHandle) {
        const file = await currentHandle.getFile();
        buf = await file.arrayBuffer();
        shownName = currentHandle.name;
      } else if (currentFile) {
        buf = await currentFile.arrayBuffer();
        shownName = currentFile.name;
      } else {
        throw new Error("먼저 엑셀 파일을 선택해 주세요.");
      }
    
      const wb = XLSX.read(buf, { type: "array" });
      const sheetName = wb.SheetNames.includes("Sheet1") ? "Sheet1" : wb.SheetNames[0];
      const ws = wb.Sheets[sheetName];
      const data = XLSX.utils.sheet_to_json(ws, { header: 1, raw: true, defval: "" });
    
      // 1) 기존 고정 파싱(A,B,C) 먼저 (현재 파일들과 호환 유지)
      const rowsFixed = [];
      for (const r of data) {
        if (!r || r.length < 2) continue;
        const day = toInt(r[0]);
        const word = (r[1] ?? "").toString().trim();
        const mean = (r[2] ?? "").toString().trim();
        if (day === null) continue;
        if (!word) continue;
        rowsFixed.push({ day, word, mean });
      }
    
      // 고정 파싱이 충분하면 그대로 사용
      // (mean이 비어 있어도 문제지는 괜찮고, 답안지는 mean 필요하니 넉넉히 조건)
      if (rowsFixed.length >= 10) {
        return { shownName, sheetName, rows: rowsFixed };
      }
    
      // 2) 부족하면 자동 추론 파싱으로 fallback
      const auto = parseFlexibleDayWordMean(data);
      if (auto.rows.length >= 10) {
        return { shownName, sheetName, rows: auto.rows };
      }
    
      // 둘 다 실패
      return { shownName, sheetName, rows: rowsFixed };
    }


    // ===== 문제 선택 로직 =====
    function shuffleInPlace(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = (Math.random() * (i + 1)) | 0;
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    function pickQuestions(rows, dayStart, dayEnd, nQuestions) {
      const days = [];
      for (let d = dayStart; d <= dayEnd; d++) days.push(d);

      const byDay = new Map();
      for (const d of days) byDay.set(d, []);
      for (const r of rows) {
        if (r.day >= dayStart && r.day <= dayEnd) byDay.get(r.day).push({ ...r });
      }

      const base = Math.floor(nQuestions / days.length);
      const rem  = nQuestions % days.length;

      const remaining = new Map();
      for (const d of days) remaining.set(d, byDay.get(d).slice());

      const chosen = [];
      let deficit = 0;

      for (let i=0;i<days.length;i++){
        const d = days[i];
        const need = base + (i < rem ? 1 : 0);
        const pool = remaining.get(d);

        if (need <= pool.length) {
          shuffleInPlace(pool);
          chosen.push(...pool.splice(0, need));
        } else {
          chosen.push(...pool.splice(0, pool.length));
          deficit += (need - pool.length);
        }
      }

      if (deficit > 0) {
        const rest = [];
        for (const d of days) rest.push(...remaining.get(d));
        assert(deficit <= rest.length, `문제 수가 데이터보다 많습니다. 가능한 최대: ${chosen.length + rest.length}`);
        shuffleInPlace(rest);
        chosen.push(...rest.slice(0, deficit));
      }

      shuffleInPlace(chosen);
      const finalChosen = chosen.slice(0, nQuestions);

      return finalChosen.map((x, idx) => ({
        no: idx+1, word: x.word, mean: x.mean, day: x.day
      }));
    }

    // ===== PDF 생성 (A4 세로, 페이지당 64문항, 세로만 중앙정렬) =====
    async function buildPdf(titleText, questions, includeMeaning) {
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({ unit: "mm", format: "a4", orientation: "portrait" });
    
      await ensureKoreanFont(doc);
    
      const pageW = 210, pageH = 297;
    
      // 가로 위치는 이전처럼(왼쪽 여백 기준)
      const tableX = 15;
    
      // 열 너비
      const wNo = 8, wWord = 34, wMean = 48;
      const colW = [wNo, wWord, wMean, wNo, wWord, wMean];
    
      // ✅ 실제 열 너비 합계만큼만 테이블 폭을 잡아야 오른쪽 빈 박스가 안 생김
      const tableW = colW.reduce((a, b) => a + b, 0); // = 180
    
      const hInfo = 0, hHead = 8, hRow = 6;
    
      // 선 굵기(원래 얇게)
      const outerLW = 0.35;
      const innerLW = 0.25;
    
      const maxPerPage = 64;
      const pageCount = Math.max(1, Math.ceil(questions.length / maxPerPage));
    
      for (let p = 0; p < pageCount; p++) {
        if (p > 0) doc.addPage();
    
        const chunk = questions.slice(p * maxPerPage, (p + 1) * maxPerPage);
        const rowsPerCol = Math.ceil(chunk.length / 2);
        const left = chunk.slice(0, rowsPerCol);
        const right = chunk.slice(rowsPerCol);
    
        // Day (작게, 위쪽 왼쪽, 박스 없음)
        doc.setFont(KOREAN_FONT_FAMILY, "normal");
        doc.setFontSize(10);
        doc.text(titleText, tableX, 10);
    
        // 표 높이
        const tableH = hInfo + hHead + (rowsPerCol * hRow);
    
        const topMargin = 18;   // Day 텍스트 아래부터 표 시작(원하면 16~25로 조절)
        let tableY = topMargin;
        let y = tableY;
    
        doc.setDrawColor(0);
    
        // 헤더
        const headerLabels = ["번호", "단어", "의미", "번호", "단어", "의미"];
        doc.setLineWidth(innerLW);
    
        let x = tableX;
        for (let c = 0; c < 6; c++) {
          doc.rect(x, y, colW[c], hHead);
          if (headerLabels[c]) doc.text(headerLabels[c], x + colW[c] / 2, y + 5.5, { align: "center" });
          x += colW[c];
        }
        y += hHead;
    
        // 본문
        doc.setFontSize(9);
    
        for (let i = 0; i < rowsPerCol; i++) {
          const L = left[i];
          const R = right[i];
    
          // Left
          let x0 = tableX;
          doc.rect(x0, y, colW[0], hRow);
          doc.rect(x0 + colW[0], y, colW[1], hRow);
          doc.rect(x0 + colW[0] + colW[1], y, colW[2], hRow);
    
          if (L) {
            doc.text(String(L.no), x0 + colW[0] / 2, y + 4.3, { align: "center" });
            doc.text(L.word, x0 + colW[0] + 2, y + 4.3);
            if (includeMeaning) doc.text(L.mean || "", x0 + colW[0] + colW[1] + 2, y + 4.3);
          }
    
          // Right
          const xr = x0 + colW[0] + colW[1] + colW[2];
          doc.rect(xr, y, colW[3], hRow);
          doc.rect(xr + colW[3], y, colW[4], hRow);
          doc.rect(xr + colW[3] + colW[4], y, colW[5], hRow);
    
          if (R) {
            doc.text(String(R.no), xr + colW[3] / 2, y + 4.3, { align: "center" });
            doc.text(R.word, xr + colW[3] + 2, y + 4.3);
            if (includeMeaning) doc.text(R.mean || "", xr + colW[3] + colW[4] + 2, y + 4.3);
          }
    
          y += hRow;
        }
    
        // 바깥 테두리(테이블 폭은 이제 정확히 열 합계라 오른쪽 빈 박스 없음)
        doc.setLineWidth(outerLW);
        doc.rect(tableX, tableY, tableW, tableH);
      }
    
      return doc.output("blob");
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }

    async function ensurePrevButtonState() {
      if (!supportsFSAccess()) {
        $("prevBtn").disabled = true;
        return;
      }
      try {
        const h = await loadLastHandle();
        $("prevBtn").disabled = !h;
        const lastName = await loadLastName();
        if (lastName && $("fileLabel").textContent.includes("(선택 안 됨)")) {
          $("fileLabel").textContent = `파일: (이전: ${lastName})`;
        }
      } catch {
        $("prevBtn").disabled = true;
      }
    }

    // ===== 이벤트 =====
    $("pickBtn").addEventListener("click", async () => {
      try { await pickExcelAuto(); }
      catch (e) { log(e.message || String(e), "bad"); }
    });

    $("prevBtn").addEventListener("click", async () => {
      try { await usePreviousFile(); }
      catch (e) { log(e.message || String(e), "bad"); }
    });

    $("genBtn").addEventListener("click", async () => {
      try {
        $("downloadQ").disabled = true;
        $("downloadA").disabled = true;
        pdfBlobQ = null;
        pdfBlobA = null;

        assert(currentHandle || currentFile, "먼저 ‘엑셀 파일 불러오기’를 해주세요.");

        const dayStart = toInt($("dayStart").value);
        const dayEnd   = toInt($("dayEnd").value);
        const count    = toInt($("count").value);

        assert(dayStart !== null && dayEnd !== null, "Day 값이 올바르지 않습니다.");
        assert(dayEnd >= dayStart, "Day 끝값이 시작값보다 작습니다.");
        assert(count !== null && count > 0, "출제 개수는 1 이상이어야 합니다.");

        log("엑셀 읽는 중…");

        const { shownName, sheetName, rows } = await readExcelFromSource();
        assert(rows.length > 0, "엑셀에서 유효한 데이터( day/단어/뜻 )를 찾지 못했습니다.");

        const inRange = rows.filter(r => r.day >= dayStart && r.day <= dayEnd);
        assert(inRange.length > 0, "해당 Day 범위에 데이터가 없습니다.");

        const questions = pickQuestions(rows, dayStart, dayEnd, count);
        const titleText = `Day ${dayStart}~${dayEnd}`;

        log(
          `파일: ${shownName}\n` +
          `선택 시트: ${sheetName}\n` +
          `데이터(범위 내): ${inRange.length}개\n` +
          `출제: ${count}문항\n` +
          `PDF 생성 중…`
        );

        pdfBlobQ = await buildPdf(titleText, questions, false);
        pdfBlobA = await buildPdf(titleText, questions, true);

        $("downloadQ").disabled = false;
        $("downloadA").disabled = false;
        log("완료! 아래 버튼으로 PDF를 다운로드하세요.", "good");
      } catch (e) {
        console.error(e);
        log(e.message || String(e), "bad");
      }
    });

    $("downloadQ").addEventListener("click", () => { if (pdfBlobQ) downloadBlob(pdfBlobQ, "문제지.pdf"); });
    $("downloadA").addEventListener("click", () => { if (pdfBlobA) downloadBlob(pdfBlobA, "답안지.pdf"); });

    (async () => {
      await ensurePrevButtonState();
      log("대기 중…");
    })();
  </script>
</body>
</html>
